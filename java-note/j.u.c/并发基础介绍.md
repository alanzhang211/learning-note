# 原理介绍
java代码在编译后变成字节码在jvm上运行，最终转换为汇编指令在cpu上执行。java所有的并发机制依赖于jvm的实现和cpu指令。

## 优点
+ 采用并发就是为了提高cpu利用率
+ 提高应用的吞吐量
+ 方便业务拆分，提高性能

## 缺点
当然，也有缺点。
+ 带来的上线文切换

减少上下文切换方法：
1. 无锁并发编程：编写多线程时避免使用锁，如：使用Hash算法，数据分片手段，让不同线程处理不同数据。
2. CAS算法：Atomic包使用CAS算法（CAS介绍见后续文章）更新数据，不需要加锁。
3. 减少使用线程数：避免创建不需要的线程（过多会导致大量线程处于等待状态）。
4. 使用协程：在单线程实现多任务的调度，并在单线程里维护多个任务间的切换。


+ 共享资源竞争问题，死锁的产生

避免死锁方法：

1. 避免一个线程获取多个锁。
2. 避免一线程在锁内占用过多的资源。
3. 尝试使用定时锁lock.tryLock(timeout)来代替内部锁机制。
4. 对于数据库锁，加锁和解锁必须在一个数据库链接中，否则会出现解锁失败的情况。


+ 资源限制

措施：
1. 对于硬件资源限制，可以使用集群并行执行程序。
2. 对于软件资源限制，可以使用资源池服用。比如：使用链接池将数据库或Socket链接进行复用。


## 进程
进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。

## 线程
线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。

## 协程
协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

```
进程、线程、协程比较:
进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。
线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。
协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。
```

## 并行
并行就是指同一时刻有两个或两个以上的“工作单位”在同时执行，从硬件的角度上来看就是同一时刻有两条或两条以上的指令处于执行阶段。

## 并发
使多个操作可以在重叠的时间段内进行，不一定同时。

来张图，比较形象。

![j.u.c ](https://github.com/alanzhang211/learning-note/raw/master/img/current-parallel.jpg)

# 源码分析
（略）

# 应用场景
## 线程池
使用线程池可以有效的提高吞吐量。如：Web容器线程池，实现HTTP连接复用。

## 任务队列
安全的任务队列能够有效的平衡机器的复杂，抵消由于峰值和波动带来的不稳定（如：使用消息队列实现“削峰处理”），有效提高服务的可靠性。同时任务队列的处理也有助于统计和分析服务的状况。

任务队列也可以在多个线程之间传递数据，有助于并行处理任务。如：“生产者-消费者”模型。

## 同步操作
并发操作的同时还需要维护数据的一致性，或多或少的会涉及到同步操作。

## 分布式锁
常见的分布式锁实现，如：Redis的setnx操作实现分布式锁。

# 实战分析
## 数据库非主键唯一性问题。
案例：
多个客户端对数据库一个非主键属性进行修改，要保证唯一性。使用数据库的唯一索引机制实现。

详情参见之前的文章[非主键自增问题小记](http://alanzhang.me/2017/12/01/%E9%9D%9E%E4%B8%BB%E9%94%AE%E8%87%AA%E5%A2%9E%E9%97%AE%E9%A2%98%E5%B0%8F%E8%AE%B0/#more) 这篇文章介绍了很多唯一性实现方案。

# FAQ
（待续）

---
*参考*
+ [并发编程的优缺点](https://www.jianshu.com/p/959cf355b574)
+ 《java并发编程的艺术》
