# 原理介绍
## JMM概念
并发编程中，线程之间的通信通过共享内存和消息传递的方式实现。

java中的线程通信通过java内存模型（JMM）控制。

![图](https://github.com/alanzhang211/learning-note/raw/master/img/JMM.png)

每个线程都有自己的独立的线程栈，每个线程栈中维护着方法中的所有局部变量。一个线程只能访问自己的线程栈。一个线程创建的局部变量对其他线程是不可见的。即使两个线程执行同样的代码，这两个线程任然需要在它们各自的线程栈中创建这些变量。

线程与线程之间可能同时对主内存中一个变量进行访问，然后再讲修改后的值同步到主内存中。这就会产生不可预知问题。

> 堆存储内容：对象、数组；栈存储内容：基本类型、对象引用。

引申：另一个线程共享区域

**方法区**
+ 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译的代码等数据。
+ 不需要连续的内存和可以选择固定大小或可扩展外，还可以选择不实现垃圾收集。

JMM规定了线程的工作内存和主内存的交互关系，以及线程之间的可见性和程序的执行顺序。一方面，要为程序员提供足够强的内存可见性保证；另一方面，对编译器和处理器的限制要尽可能地放松。


# FAQ
1. 线程之间如何进行通信，如何进行同步。

通过**共享内存**和**消息传递**的方式。

2. 内存可见性问题

两种处理方式：
通过**volatile** 和**synchronized**同步方式实现。

**两者的区别:**
```
volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。

volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。

volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。

volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。

volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化.
```
